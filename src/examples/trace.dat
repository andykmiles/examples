 --- modulename: threads, funcname: <module>
threads.py(1): import threading
threads.py(2): import time
threads.py(6): class shared:
 --- modulename: threads, funcname: shared
threads.py(6): class shared:
threads.py(7):         val = 1
threads.py(9): def func():
threads.py(15): threads = []
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restorethreads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs

threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: waitthreads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)

threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(11):     time.sleep(0.00001)
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restorethreads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs

threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: waitthreads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)

threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(19):     thread = threading.Thread(target=func)
 --- modulename: threading, funcname: __init__
threading.py(781):         assert group is None, "group argument must be None for now"
threading.py(782):         if kwargs is None:
threading.py(783):             kwargs = {}
threading.py(784):         self._target = target
threading.py(785):         self._name = str(name or _newname())
 --- modulename: threading, funcname: _newname
threading.py(729):     return template % _counter()
threading.py(786):         self._args = args
threading.py(787):         self._kwargs = kwargs
threading.py(788):         if daemon is not None:
threading.py(791):             self._daemonic = current_thread().daemon
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
 --- modulename: threading, funcname: daemon
threading.py(1117):         assert self._initialized, "Thread.__init__() not called"
threading.py(1118):         return self._daemonic
threading.py(792):         self._ident = None
threading.py(793):         self._tstate_lock = None
threading.py(794):         self._started = Event()
 --- modulename: threading, funcname: __init__
threading.py(500):         self._cond = Condition(Lock())
 --- modulename: threading, funcname: __init__
threading.py(217):         if lock is None:
threading.py(219):         self._lock = lock
threading.py(221):         self.acquire = lock.acquire
threading.py(222):         self.release = lock.release
threading.py(226):         try:
threading.py(227):             self._release_save = lock._release_save
threading.py(228):         except AttributeError:
threading.py(229):             pass
threading.py(230):         try:
threading.py(231):             self._acquire_restore = lock._acquire_restore
threading.py(232):         except AttributeError:
threading.py(233):             pass
threading.py(234):         try:
threading.py(235):             self._is_owned = lock._is_owned
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(236):         except AttributeError:
threading.py(237):             pass
threading.py(238):         self._waiters = _deque()
threading.py(501):         self._flag = False
threading.py(795):         self._is_stopped = False
threading.py(796):         self._initialized = True
threading.py(799):         self._stderr = _sys.stderr
threading.py(801):         _dangling.add(self)
 --- modulename: _weakrefset, funcname: add
_weakrefset.py(82):         if self._pending_removals:
_weakrefset.py(84):         self.data.add(ref(item, self._remove))
threads.py(20):     threads.append(thread)
threads.py(21):     thread.start()
 --- modulename: threading, funcname: start
threading.py(839):         if not self._initialized:
threading.py(842):         if self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(844):         with _active_limbo_lock:
threading.py(845):             _limbo[self] = self
threading.py(846):         try:
threading.py(847):             _start_new_thread(self._bootstrap, ())
threading.py(852):         self._started.wait()
 --- modulename: threading, funcname: wait
threading.py(549):         with self._cond:
 --- modulename: threading, funcname: __enter__
threading.py(241):         return self._lock.__enter__()
threading.py(550):             signaled = self._flag
threading.py(551):             if not signaled:
threading.py(552):                 signaled = self._cond.wait(timeout)
 --- modulename: threading, funcname: wait
threading.py(287):         if not self._is_owned():
 --- modulename: threading, funcname: _is_owned
threading.py(258):         if self._lock.acquire(0):
threading.py(262):             return True
threading.py(289):         waiter = _allocate_lock()
threading.py(290):         waiter.acquire()
threading.py(291):         self._waiters.append(waiter)
threading.py(292):         saved_state = self._release_save()
 --- modulename: threading, funcname: _release_save
threading.py(250):         self._lock.release()           # No state to save
threading.py(293):         gotit = False
threading.py(294):         try:    # restore state no matter what (e.g., KeyboardInterrupt)
threading.py(295):             if timeout is None:
threading.py(296):                 waiter.acquire()
 --- modulename: threading, funcname: run
threading.py(863):         try:
threading.py(864):             if self._target:
threading.py(865):                 self._target(*self._args, **self._kwargs)
 --- modulename: threads, funcname: func
threads.py(10):     y = shared.val
threads.py(11):     time.sleep(0.00001)
threading.py(297):                 gotit = True
threading.py(303):             return gotit
threading.py(305):             self._acquire_restore(saved_state)
 --- modulename: threading, funcname: _acquire_restore
threading.py(253):         self._lock.acquire()           # Ignore saved state
threading.py(306):             if not gotit:
threading.py(553):             return signaled
 --- modulename: threading, funcname: __exit__
threading.py(244):         return self._lock.__exit__(*args)
threads.py(18): for i in range(100):
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threads.py(12):     y += 1
threads.py(13):     shared.val = y
threading.py(869):             del self._target, self._args, self._kwargs
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(24):     thread.join()
 --- modulename: threading, funcname: join
threading.py(1024):         if not self._initialized:
threading.py(1026):         if not self._started.is_set():
 --- modulename: threading, funcname: is_set
threading.py(509):         return self._flag
threading.py(1028):         if self is current_thread():
 --- modulename: threading, funcname: current_thread
threading.py(1221):     try:
threading.py(1222):         return _active[get_ident()]
threading.py(1031):         if timeout is None:
threading.py(1032):             self._wait_for_tstate_lock()
 --- modulename: threading, funcname: _wait_for_tstate_lock
threading.py(1045):         lock = self._tstate_lock
threading.py(1046):         if lock is None:  # already determined that the C code is done
threading.py(1048):         elif lock.acquire(block, timeout):
threading.py(1049):             lock.release()
threading.py(1050):             self._stop()
 --- modulename: threading, funcname: _stop
threading.py(985):         lock = self._tstate_lock
threading.py(986):         if lock is not None:
threading.py(987):             assert not lock.locked()
threading.py(988):         self._is_stopped = True
threading.py(989):         self._tstate_lock = None
threads.py(23): for thread in threads:
threads.py(26): print(shared.val)
99
